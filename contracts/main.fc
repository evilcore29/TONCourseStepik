#include "imports/stdlib.fc";

;; суть задачи: пишем контракт который принимает сообщение, записывает адрес отправителя в ячейку, и имеет геттер который может отдать адрес последнего отправителя сообщения

;; recv_internal обрабатывает входящее сообщение
() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
  ;; opcode хранится в in_msg_body
  ;; slice — это адрес определенного фрагмента, указатель на него
  slice cs = in_msg.begin_parse();
  ;; парсим 4-битное целое число, вызывая load_uint(4), и присваиваем результат для внутренней переменной flags.
  int flags = cs~load_uint(4);

  ;; Как только мы собираемся вызвать еще одну ~load_{*} для переменной cs, мы фактически продолжим разбор с того места, где закончилась предыдущая ~load_{*}.
  ;; работает как курсор
  ;; тут забираем адрес отправителя сообщения
  ;; Когда мы хотим создать переменную, хранящую адрес, мы всегда используем тип slice, чтобы хранить только указатель, откуда память должна прочитать адрес, как только он понадобится.
  slice sender_address = cs~load_msg_addr();

  ;; читаем 32-битное целое число, для получения opcode, после load_uint(4)
  int op = in_msg_body~load_uint(32);

  if (op == 1) {
    ;; counter logic is coming here:
    ;; объявляем переменную ds
    ;; get_data() Возвращает ячейку хранения постоянного контракта. В дальнейшем она может быть разобрана или изменена с помощью примитивов slice и builder.
    slice ds = get_data().begin_parse();
    ;; объявляем переменную counter_value
    int counter_value = ds~load_uint(32);
    ;; set_data() Устанавливает ячейку в качестве данных постоянного контракта. С помощью этого примитива можно обновлять хранилище постоянных контрактов.
    set_data(begin_cell().store_uint(counter_value + 1, 32).store_slice(sender_address).end_cell());
    return();
  }
  return();
}

(int, slice) get_contract_storage_data() method_id {
  slice ds = get_data().begin_parse();
  return (
    ;; counter_value
    ds~load_uint(32), 
    ;; the most recent sender
    ds~load_msg_addr() 
  );
}